
//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}


//Write a Program to implement FCFS Non-Pre-emptive Process Scheduling Algorithm.


#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyAT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].AT < processes[minIndex].AT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    int avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyAT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a Program to implement SJF Non-Pre-emptive Algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
};

//selectionSort
void sortbyBT(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        int minIndex = i;
        for (int j = i + 1; j < n; ++j) {
            if (processes[j].BT < processes[minIndex].BT) {
                minIndex = j;
            }
        }
        swap(processes[i], processes[minIndex]);
    }
}

        void SortbyID(Process processes[], int n) {
             for (int i = 0; i < n - 1; ++i) {
                int minIndex = i;
                for (int j = i + 1; j < n; ++j) {
                    if (processes[j].id < processes[minIndex].id) {
                         minIndex = j;
                 }
                }
             swap(processes[i], processes[minIndex]);
        }
    }

int main() {
    int n; // Number of processes
    float avgCT,avgTAT,avgWT,avgRT;
    cout << "Num of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
    }

    sortbyBT(processes, n);

int currentExecutionTime = 0;

for (int i = 0; i < n; ++i) {
    if (processes[i].AT > currentExecutionTime) {
        currentExecutionTime = processes[i].AT;
    }

processes[i].RT = currentExecutionTime - processes[i].AT;

    processes[i].CT = currentExecutionTime + processes[i].BT;

    processes[i].TAT = processes[i].CT - processes[i].AT;

    processes[i].WT = processes[i].TAT - processes[i].BT;

    currentExecutionTime = processes[i].CT;
}

        SortbyID(processes,n);

cout << "\nFCFS Scheduling Results:\n";
    cout << "Process\tArrivial\tBurst\tCompletion \tTurnaround \tWaiting \tResponse \n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT<< "\t\t" <<processes[i].BT << "\t\t"<<processes[i].CT << "\t\t"
             << processes[i].TAT << "\t\t" << processes[i].WT << "\t\t"
             << processes[i].RT << endl;

        avgCT += processes[i].CT;
        avgTAT += processes[i].TAT;
        avgWT += processes[i].WT;
        
        avgRT += processes[i].RT;
    }
    cout<<"\n\nTotal\n";
    cout<<"\t\t\t\t\t"<<avgCT<< "\t\t"<<avgTAT<<"\t\t"<<avgWT<<"\t\t"<<avgRT<<endl;

    cout<<"\n\nAverages\n";
    cout<<"\t\t\t\t\t"<<avgCT/n<< "\t\t"<<avgTAT/n<<"\t\t"<<avgWT/n<<"\t\t"<<avgRT/n;

    return 0;
}



 

//Write a program to implement SRTF algorithm.
#include <iostream>

using namespace std;

struct Process {
    int id;
    int AT;
    int BT;
    int CT;
    int TAT;
    int WT;
    int RT;
    int remainingTime;
};

void sortByArrivalTime(Process processes[], int n) {
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (processes[j].AT > processes[j + 1].AT) {
                swap(processes[j], processes[j + 1]);
            }
        }
    }
}

int main() {
    int n; // Number of processes
    float avgCT = 0, avgTAT = 0, avgWT = 0, avgRT = 0;

    cout << "Number of processes: ";
    cin >> n;

    Process processes[n];

    for (int i = 0; i < n; ++i) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for Process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for Process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remainingTime = processes[i].BT;
    }

    int currentTime = 0;
    int completedProcesses = 0;

    while (completedProcesses < n) {
        sortByArrivalTime(processes, n);
        int shortestProcess = -1;
        int shortestTime = 999;

        for (int i = 0; i < n; ++i) {
            if (processes[i].AT <= currentTime && processes[i].remainingTime > 0) {
                if (processes[i].remainingTime < shortestTime) {
                    shortestTime = processes[i].remainingTime;
                    shortestProcess = i;
                }
            }
        }

        if (shortestProcess == -1) {
            currentTime++;
        } else {
            if (processes[shortestProcess].remainingTime == processes[shortestProcess].BT) {
                // Process is starting for the first time
                processes[shortestProcess].RT = currentTime - processes[shortestProcess].AT;
            }

            processes[shortestProcess].remainingTime--;

            if (processes[shortestProcess].remainingTime == 0) {
                completedProcesses++;
                processes[shortestProcess].CT = currentTime + 1;
                processes[shortestProcess].TAT = processes[shortestProcess].CT - processes[shortestProcess].AT;
                processes[shortestProcess].WT = processes[shortestProcess].TAT - processes[shortestProcess].BT;

                avgCT += processes[shortestProcess].CT;
                avgTAT += processes[shortestProcess].TAT;
                avgWT += processes[shortestProcess].WT;
            }

            currentTime++;
        }
    }

    cout << "\nSRTF Scheduling Results:\n";
    cout << "Process\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\tResponse\n";
    for (int i = 0; i < n; ++i) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t" << processes[i].CT << "\t"
             << processes[i].TAT << "\t" << processes[i].WT << "\t" << processes[i].RT << endl;
    }

    cout << "\n\nTotal\n";
    cout << "\t\t\t\t" << avgCT << "\t" << avgTAT << "\t" << avgWT << endl;

    cout << "\n\nAverages\n";
    cout << "\t\t\t\t" << avgCT / n << "\t" << avgTAT / n << "\t" << avgWT / n;

    return 0;
}


 

//Write a program to implement Priority Algorithm (preemptive)


#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int proirity[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("   %d\t     %d\t     %d\t     %d\t     %d\t\t     %d\n", proc[i],proirity[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } 
        else {
            remaining_time[selected_process]--;

            if (remaining_time[selected_process] == 0) {
                completed++;
                completion_time[selected_process] = current_time+1;
                turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            }
            
            current_time++;
        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 5, 4, 2, 1};
   int priority[] = { 10, 20, 30, 40};
   int arrival_time[] = { 0, 1, 2,4};
   int completion_time[n], tat[n];

   // Call the scheduling function
   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n,priority ,arrival_time, burst_time, completion_time, tat);

   return 0;
}


//Write a program to implement Priority algorithm (non preemptive)
#include <stdio.h>

void turnaroundtime(int proc[], int n, int burst_time[], int tat[], int completion_time[], int arrival_time[]) {
   for (int i = 0; i < n; i++) {
      tat[i] = completion_time[i] - arrival_time[i];
   }
}

void displayDetails(int proc[], int n,int priority[], int arrival_time[], int burst_time[], int completion_time[], int tat[]) {
   printf("Processes  Priority  Arrival   Burst   Completion   Turnaround\n");

   for (int i = 0; i < n; i++) {
      printf("  %d\t\t%d\t  %d\t     %d\t     %d\t     %d\n", proc[i],priority[i], arrival_time[i], burst_time[i], completion_time[i], tat[i]);
   }
}

void priorityScheduling(int proc[], int n, int burst_time[], int priority[], int arrival_time[], int completion_time[], int turnaround_time[]) {
    int remaining_time[n];

    // Initialize remaining time and completion time arrays
    for (int i = 0; i < n; i++) {
        remaining_time[i] = burst_time[i];
        
    }

    int current_time = 0;
    int completed = 0;

    while (completed < n) {
        int highest_priority = -1;
        int selected_process = -1;

        for (int i = 0; i < n; i++) {
            if (arrival_time[i] <= current_time && remaining_time[i] > 0 && priority[i] > highest_priority) {
                highest_priority = priority[i]; 
                selected_process = i;
            }
        }

        if (selected_process == -1) {
            current_time++;
        } else {
            completion_time[selected_process] = current_time + burst_time[selected_process];
            turnaround_time[selected_process] = completion_time[selected_process] - arrival_time[selected_process];
            remaining_time[selected_process] = 0;
            current_time = completion_time[selected_process];
            completed++;

        }
    }
}

int main() {
   // Process id's
   int proc[] = { 1, 2, 3, 4, 5};
   int n = sizeof(proc) / sizeof(proc[0]);

   // Burst time, priority, and arrival time of all processes
   int burst_time[] = { 6, 8, 7, 3, 4 };
   int priority[] = { 3, 1, 4, 2, 5 };
   int arrival_time[] = { 0, 1, 2, 3, 4 };
   int completion_time[n], tat[n];

   priorityScheduling(proc, n, burst_time, priority, arrival_time, completion_time, tat);

   // Calculate turnaround time
   turnaroundtime(proc, n, burst_time, tat, completion_time, arrival_time);

   // Display process details
   displayDetails(proc, n, priority, arrival_time, burst_time, completion_time, tat);

   return 0;
}

//Write A program to implement Round Robin Algorithm
#include <iostream>
#include <queue>

using namespace std;

#define MAX_PROCESSES 10

// Process structure
struct Process {
    int id;            // Process ID
    int AT;            // Arrival Time
    int BT;            // Burst Time
    int remaining_BT;  // Remaining Burst Time
    int CT;            // Completion Time
    int TAT;           // Turnaround Time
    int WT;            // Waiting Time
    int RT;            // Response Time
};

// Function to perform Round Robin scheduling
void roundRobin(Process processes[], int num_processes, int TQ) {
    int total_time = 0;
    int completed = 0;

    int current_time = 0;
    int current_process = 0;

    queue<int> ready_queue;

    while (completed < num_processes) {
        // Check if the process has arrived
        while (current_process < num_processes && processes[current_process].AT <= current_time) {
            ready_queue.push(current_process);
            current_process++;
        }

        if (!ready_queue.empty()) {
            int next_process = ready_queue.front();
            ready_queue.pop();

            // Check if it's the first time the process is executing
            if (processes[next_process].RT == -1) {
                processes[next_process].RT = current_time - processes[next_process].AT;
            }

            // Execute the current process for the time quantum or until it completes
            if (processes[next_process].remaining_BT > TQ) {
                current_time += TQ;
                processes[next_process].remaining_BT -= TQ;
            } else {
                current_time += processes[next_process].remaining_BT;
                processes[next_process].remaining_BT = 0;

                processes[next_process].CT = current_time;
                processes[next_process].TAT = processes[next_process].CT - processes[next_process].AT;
                processes[next_process].WT = processes[next_process].TAT - processes[next_process].BT;

                completed++;
            }
            // Re-add the process to the queue if it still has work remaining
            if (processes[next_process].remaining_BT > 0) {
                ready_queue.push(next_process);
            }
        } else {
            // If no process is available, increment current_time
            current_time++;
        }

        // Update the total time
        total_time = current_time;
    }

    // Display the results
    cout << "Process\tAT\tBT\tCT\tTAT\tWT\tRT" << endl;
    for (int i = 0; i < num_processes; i++) {
        cout << processes[i].id << "\t" << processes[i].AT << "\t" << processes[i].BT << "\t"
             << processes[i].CT << "\t" << processes[i].TAT << "\t" << processes[i].WT << "\t"
             << processes[i].RT << endl;
    }

    cout << "Total execution time: " << total_time << endl;
}

int main() {
    int num_processes, TQ;
    cout << "Enter the number of processes: ";
    cin >> num_processes;

    if (num_processes <= 0 || num_processes > MAX_PROCESSES) {
        cout << "Invalid number of processes. Please enter a value between 1 and " << MAX_PROCESSES << endl;
        return 1;
    }

    cout << "Enter the time quantum (TQ): ";
    cin >> TQ;

    Process processes[MAX_PROCESSES];

    // Initialize processes
    for (int i = 0; i < num_processes; i++) {
        processes[i].id = i + 1;
        cout << "Enter arrival time for process " << i + 1 << ": ";
        cin >> processes[i].AT;
        cout << "Enter burst time for process " << i + 1 << ": ";
        cin >> processes[i].BT;
        processes[i].remaining_BT = processes[i].BT;
        processes[i].CT = 0;
        processes[i].TAT = 0;
        processes[i].WT = 0;
        processes[i].RT = -1;
    }

    roundRobin(processes, num_processes, TQ);

    return 0;
}

// C program for implementation of FCFS 
// scheduling 
#include<stdio.h> 
// Function to find the waiting time for all 
// processes 
void findWaitingTime(int processes[], int n, 
						int bt[], int wt[]) 
{ 
	// waiting time for first process is 0 
	wt[0] = 0; 

	// calculating waiting time 
	for (int i = 1; i < n ; i++ ) 
		wt[i] = bt[i-1] + wt[i-1] ; 
} 

// Function to calculate turn around time 
void findTurnAroundTime( int processes[], int n, 
				int bt[], int wt[], int tat[]) 
{ 
	// calculating turnaround time by adding 
	// bt[i] + wt[i] 
	for (int i = 0; i < n ; i++) 
		tat[i] = bt[i] + wt[i]; 
} 

//Function to calculate average time 
void findavgTime( int processes[], int n, int bt[]) 
{ 
	int wt[n], tat[n], total_wt = 0, total_tat = 0; 

	//Function to find waiting time of all processes 
	findWaitingTime(processes, n, bt, wt); 

	//Function to find turn around time for all processes 
	findTurnAroundTime(processes, n, bt, wt, tat); 

	//Display processes along with all details 
	printf("Processes Burst time Waiting time Turn around time\n"); 

	// Calculate total waiting time and total turn 
	// around time 
	for (int i=0; i<n; i++) 
	{ 
		total_wt = total_wt + wt[i]; 
		total_tat = total_tat + tat[i]; 
		printf(" %d ",(i+1));
		printf("	 %d ", bt[i] );
		printf("	 %d",wt[i] );
		printf("	 %d\n",tat[i] ); 
	} 
	float s=(float)total_wt / (float)n;
	float t=(float)total_tat / (float)n;
	printf("Average waiting time = %f",s);
	printf("\n");
	printf("Average turn around time = %f ",t); 
} 

// Driver code 
int main() 
{ 
	//process id's 
	int processes[] = { 1, 2, 3}; 
	int n = sizeof processes / sizeof processes[0]; 

	//Burst time of all processes 
	int burst_time[] = {10, 5, 8}; 

	findavgTime(processes, n, burst_time); 
	return 0; 
} 
// This code is contributed by Shivi_Aggarwal
// C program for implementation of FCFS 
// scheduling 
#include<stdio.h> 
// Function to find the waiting time for all 
// processes 
void findWaitingTime(int processes[], int n, 
						int bt[], int wt[]) 
{ 
	// waiting time for first process is 0 
	wt[0] = 0; 

	// calculating waiting time 
	for (int i = 1; i < n ; i++ ) 
		wt[i] = bt[i-1] + wt[i-1] ; 
} 

// Function to calculate turn around time 
void findTurnAroundTime( int processes[], int n, 
				int bt[], int wt[], int tat[]) 
{ 
	// calculating turnaround time by adding 
	// bt[i] + wt[i] 
	for (int i = 0; i < n ; i++) 
		tat[i] = bt[i] + wt[i]; 
} 

//Function to calculate average time 
void findavgTime( int processes[], int n, int bt[]) 
{ 
	int wt[n], tat[n], total_wt = 0, total_tat = 0; 

	//Function to find waiting time of all processes 
	findWaitingTime(processes, n, bt, wt); 

	//Function to find turn around time for all processes 
	findTurnAroundTime(processes, n, bt, wt, tat); 

	//Display processes along with all details 
	printf("Processes Burst time Waiting time Turn around time\n"); 

	// Calculate total waiting time and total turn 
	// around time 
	for (int i=0; i<n; i++) 
	{ 
		total_wt = total_wt + wt[i]; 
		total_tat = total_tat + tat[i]; 
		printf(" %d ",(i+1));
		printf("	 %d ", bt[i] );
		printf("	 %d",wt[i] );
		printf("	 %d\n",tat[i] ); 
	} 
	float s=(float)total_wt / (float)n;
	float t=(float)total_tat / (float)n;
	printf("Average waiting time = %f",s);
	printf("\n");
	printf("Average turn around time = %f ",t); 
} 

// Driver code 
int main() 
{ 
	//process id's 
	int processes[] = { 1, 2, 3}; 
	int n = sizeof processes / sizeof processes[0]; 

	//Burst time of all processes 
	int burst_time[] = {10, 5, 8}; 

	findavgTime(processes, n, burst_time); 
	return 0; 
} 
// This code is contributed by Shivi_Aggarwal
// C program for implementation of FCFS 
// scheduling 
#include<stdio.h> 
// Function to find the waiting time for all 
// processes 
void findWaitingTime(int processes[], int n, 
						int bt[], int wt[]) 
{ 
	// waiting time for first process is 0 
	wt[0] = 0; 

	// calculating waiting time 
	for (int i = 1; i < n ; i++ ) 
		wt[i] = bt[i-1] + wt[i-1] ; 
} 

// Function to calculate turn around time 
void findTurnAroundTime( int processes[], int n, 
				int bt[], int wt[], int tat[]) 
{ 
	// calculating turnaround time by adding 
	// bt[i] + wt[i] 
	for (int i = 0; i < n ; i++) 
		tat[i] = bt[i] + wt[i]; 
} 

//Function to calculate average time 
void findavgTime( int processes[], int n, int bt[]) 
{ 
	int wt[n], tat[n], total_wt = 0, total_tat = 0; 

	//Function to find waiting time of all processes 
	findWaitingTime(processes, n, bt, wt); 

	//Function to find turn around time for all processes 
	findTurnAroundTime(processes, n, bt, wt, tat); 

	//Display processes along with all details 
	printf("Processes Burst time Waiting time Turn around time\n"); 

	// Calculate total waiting time and total turn 
	// around time 
	for (int i=0; i<n; i++) 
	{ 
		total_wt = total_wt + wt[i]; 
		total_tat = total_tat + tat[i]; 
		printf(" %d ",(i+1));
		printf("	 %d ", bt[i] );
		printf("	 %d",wt[i] );
		printf("	 %d\n",tat[i] ); 
	} 
	float s=(float)total_wt / (float)n;
	float t=(float)total_tat / (float)n;
	printf("Average waiting time = %f",s);
	printf("\n");
	printf("Average turn around time = %f ",t); 
} 

// Driver code 
int main() 
{ 
	//process id's 
	int processes[] = { 1, 2, 3}; 
	int n = sizeof processes / sizeof processes[0]; 

	//Burst time of all processes 
	int burst_time[] = {10, 5, 8}; 

	findavgTime(processes, n, burst_time); 
	return 0; 
} 
// This code is contributed by Shivi_Aggarwal
// C program for implementation of FCFS 
// scheduling 
#include<stdio.h> 
// Function to find the waiting time for all 
// processes 
void findWaitingTime(int processes[], int n, 
						int bt[], int wt[]) 
{ 
	// waiting time for first process is 0 
	wt[0] = 0; 

	// calculating waiting time 
	for (int i = 1; i < n ; i++ ) 
		wt[i] = bt[i-1] + wt[i-1] ; 
} 

// Function to calculate turn around time 
void findTurnAroundTime( int processes[], int n, 
				int bt[], int wt[], int tat[]) 
{ 
	// calculating turnaround time by adding 
	// bt[i] + wt[i] 
	for (int i = 0; i < n ; i++) 
		tat[i] = bt[i] + wt[i]; 
} 

//Function to calculate average time 
void findavgTime( int processes[], int n, int bt[]) 
{ 
	int wt[n], tat[n], total_wt = 0, total_tat = 0; 

	//Function to find waiting time of all processes 
	findWaitingTime(processes, n, bt, wt); 

	//Function to find turn around time for all processes 
	findTurnAroundTime(processes, n, bt, wt, tat); 

	//Display processes along with all details 
	printf("Processes Burst time Waiting time Turn around time\n"); 

	// Calculate total waiting time and total turn 
	// around time 
	for (int i=0; i<n; i++) 
	{ 
		total_wt = total_wt + wt[i]; 
		total_tat = total_tat + tat[i]; 
		printf(" %d ",(i+1));
		printf("	 %d ", bt[i] );
		printf("	 %d",wt[i] );
		printf("	 %d\n",tat[i] ); 
	} 
	float s=(float)total_wt / (float)n;
	float t=(float)total_tat / (float)n;
	printf("Average waiting time = %f",s);
	printf("\n");
	printf("Average turn around time = %f ",t); 
} 

// Driver code 
int main() 
{ 
	//process id's 
	int processes[] = { 1, 2, 3}; 
	int n = sizeof processes / sizeof processes[0]; 

	//Burst time of all processes 
	int burst_time[] = {10, 5, 8}; 

	findavgTime(processes, n, burst_time); 
	return 0; 
} 
// This code is contributed by Shivi_Aggarwal
// C program for implementation of FCFS 
// scheduling 
#include<stdio.h> 
// Function to find the waiting time for all 
// processes 
void findWaitingTime(int processes[], int n, 
						int bt[], int wt[]) 
{ 
	// waiting time for first process is 0 
	wt[0] = 0; 

	// calculating waiting time 
	for (int i = 1; i < n ; i++ ) 
		wt[i] = bt[i-1] + wt[i-1] ; 
} 

// Function to calculate turn around time 
void findTurnAroundTime( int processes[], int n, 
				int bt[], int wt[], int tat[]) 
{ 
	// calculating turnaround time by adding 
	// bt[i] + wt[i] 
	for (int i = 0; i < n ; i++) 
		tat[i] = bt[i] + wt[i]; 
} 

//Function to calculate average time 
void findavgTime( int processes[], int n, int bt[]) 
{ 
	int wt[n], tat[n], total_wt = 0, total_tat = 0; 

	//Function to find waiting time of all processes 
	findWaitingTime(processes, n, bt, wt); 

	//Function to find turn around time for all processes 
	findTurnAroundTime(processes, n, bt, wt, tat); 

	//Display processes along with all details 
	printf("Processes Burst time Waiting time Turn around time\n"); 

	// Calculate total waiting time and total turn 
	// around time 
	for (int i=0; i<n; i++) 
	{ 
		total_wt = total_wt + wt[i]; 
		total_tat = total_tat + tat[i]; 
		printf(" %d ",(i+1));
		printf("	 %d ", bt[i] );
		printf("	 %d",wt[i] );
		printf("	 %d\n",tat[i] ); 
	} 
	float s=(float)total_wt / (float)n;
	float t=(float)total_tat / (float)n;
	printf("Average waiting time = %f",s);
	printf("\n");
	printf("Average turn around time = %f ",t); 
} 

// Driver code 
int main() 
{ 
	//process id's 
	int processes[] = { 1, 2, 3}; 
	int n = sizeof processes / sizeof processes[0]; 

	//Burst time of all processes 
	int burst_time[] = {10, 5, 8}; 

	findavgTime(processes, n, burst_time); 
	return 0; 
} 
// This code is contributed by Shivi_Aggarwal
// C program for implementation of FCFS 
// scheduling 
#include<stdio.h> 
// Function to find the waiting time for all 
// processes 
void findWaitingTime(int processes[], int n, 
						int bt[], int wt[]) 
{ 
	// waiting time for first process is 0 
	wt[0] = 0; 

	// calculating waiting time 
	for (int i = 1; i < n ; i++ ) 
		wt[i] = bt[i-1] + wt[i-1] ; 
} 

// Function to calculate turn around time 
void findTurnAroundTime( int processes[], int n, 
				int bt[], int wt[], int tat[]) 
{ 
	// calculating turnaround time by adding 
	// bt[i] + wt[i] 
	for (int i = 0; i < n ; i++) 
		tat[i] = bt[i] + wt[i]; 
} 

//Function to calculate average time 
void findavgTime( int processes[], int n, int bt[]) 
{ 
	int wt[n], tat[n], total_wt = 0, total_tat = 0; 

	//Function to find waiting time of all processes 
	findWaitingTime(processes, n, bt, wt); 

	//Function to find turn around time for all processes 
	findTurnAroundTime(processes, n, bt, wt, tat); 

	//Display processes along with all details 
	printf("Processes Burst time Waiting time Turn around time\n"); 

	// Calculate total waiting time and total turn 
	// around time 
	for (int i=0; i<n; i++) 
	{ 
		total_wt = total_wt + wt[i]; 
		total_tat = total_tat + tat[i]; 
		printf(" %d ",(i+1));
		printf("	 %d ", bt[i] );
		printf("	 %d",wt[i] );
		printf("	 %d\n",tat[i] ); 
	} 
	float s=(float)total_wt / (float)n;
	float t=(float)total_tat / (float)n;
	printf("Average waiting time = %f",s);
	printf("\n");
	printf("Average turn around time = %f ",t); 
} 

// Driver code 
int main() 
{ 
	//process id's 
	int processes[] = { 1, 2, 3}; 
	int n = sizeof processes / sizeof processes[0]; 

	//Burst time of all processes 
	int burst_time[] = {10, 5, 8}; 

	findavgTime(processes, n, burst_time); 
	return 0; 
} 
// This code is contributed by Shivi_Aggarwal
// C program for implementation of FCFS 
// scheduling 
#include<stdio.h> 
// Function to find the waiting time for all 
// processes 
void findWaitingTime(int processes[], int n, 
						int bt[], int wt[]) 
{ 
	// waiting time for first process is 0 
	wt[0] = 0; 

	// calculating waiting time 
	for (int i = 1; i < n ; i++ ) 
		wt[i] = bt[i-1] + wt[i-1] ; 
} 

// Function to calculate turn around time 
void findTurnAroundTime( int processes[], int n, 
				int bt[], int wt[], int tat[]) 
{ 
	// calculating turnaround time by adding 
	// bt[i] + wt[i] 
	for (int i = 0; i < n ; i++) 
		tat[i] = bt[i] + wt[i]; 
} 

//Function to calculate average time 
void findavgTime( int processes[], int n, int bt[]) 
{ 
	int wt[n], tat[n], total_wt = 0, total_tat = 0; 

	//Function to find waiting time of all processes 
	findWaitingTime(processes, n, bt, wt); 

	//Function to find turn around time for all processes 
	findTurnAroundTime(processes, n, bt, wt, tat); 

	//Display processes along with all details 
	printf("Processes Burst time Waiting time Turn around time\n"); 

	// Calculate total waiting time and total turn 
	// around time 
	for (int i=0; i<n; i++) 
	{ 
		total_wt = total_wt + wt[i]; 
		total_tat = total_tat + tat[i]; 
		printf(" %d ",(i+1));
		printf("	 %d ", bt[i] );
		printf("	 %d",wt[i] );
		printf("	 %d\n",tat[i] ); 
	} 
	float s=(float)total_wt / (float)n;
	float t=(float)total_tat / (float)n;
	printf("Average waiting time = %f",s);
	printf("\n");
	printf("Average turn around time = %f ",t); 
} 

// Driver code 
int main() 
{ 
	//process id's 
	int processes[] = { 1, 2, 3}; 
	int n = sizeof processes / sizeof processes[0]; 

	//Burst time of all processes 
	int burst_time[] = {10, 5, 8}; 

	findavgTime(processes, n, burst_time); 
	return 0; 
} 
// This code is contributed by Shivi_Aggarwal
// C program for implementation of FCFS 
// scheduling 
#include<stdio.h> 
// Function to find the waiting time for all 
// processes 
void findWaitingTime(int processes[], int n, 
						int bt[], int wt[]) 
{ 
	// waiting time for first process is 0 
	wt[0] = 0; 

	// calculating waiting time 
	for (int i = 1; i < n ; i++ ) 
		wt[i] = bt[i-1] + wt[i-1] ; 
} 

// Function to calculate turn around time 
void findTurnAroundTime( int processes[], int n, 
				int bt[], int wt[], int tat[]) 
{ 
	// calculating turnaround time by adding 
	// bt[i] + wt[i] 
	for (int i = 0; i < n ; i++) 
		tat[i] = bt[i] + wt[i]; 
} 

//Function to calculate average time 
void findavgTime( int processes[], int n, int bt[]) 
{ 
	int wt[n], tat[n], total_wt = 0, total_tat = 0; 

	//Function to find waiting time of all processes 
	findWaitingTime(processes, n, bt, wt); 

	//Function to find turn around time for all processes 
	findTurnAroundTime(processes, n, bt, wt, tat); 

	//Display processes along with all details 
	printf("Processes Burst time Waiting time Turn around time\n"); 

	// Calculate total waiting time and total turn 
	// around time 
	for (int i=0; i<n; i++) 
	{ 
		total_wt = total_wt + wt[i]; 
		total_tat = total_tat + tat[i]; 
		printf(" %d ",(i+1));
		printf("	 %d ", bt[i] );
		printf("	 %d",wt[i] );
		printf("	 %d\n",tat[i] ); 
	} 
	float s=(float)total_wt / (float)n;
	float t=(float)total_tat / (float)n;
	printf("Average waiting time = %f",s);
	printf("\n");
	printf("Average turn around time = %f ",t); 
} 

// Driver code 
int main() 
{ 
	//process id's 
	int processes[] = { 1, 2, 3}; 
	int n = sizeof processes / sizeof processes[0]; 

	//Burst time of all processes 
	int burst_time[] = {10, 5, 8}; 

	findavgTime(processes, n, burst_time); 
	return 0; 
} 
// This code is contributed by Shivi_Aggarwal
// C program for implementation of FCFS 
// scheduling 
#include<stdio.h> 
// Function to find the waiting time for all 
// processes 
void findWaitingTime(int processes[], int n, 
						int bt[], int wt[]) 
{ 
	// waiting time for first process is 0 
	wt[0] = 0; 

	// calculating waiting time 
	for (int i = 1; i < n ; i++ ) 
		wt[i] = bt[i-1] + wt[i-1] ; 
} 

// Function to calculate turn around time 
void findTurnAroundTime( int processes[], int n, 
				int bt[], int wt[], int tat[]) 
{ 
	// calculating turnaround time by adding 
	// bt[i] + wt[i] 
	for (int i = 0; i < n ; i++) 
		tat[i] = bt[i] + wt[i]; 
} 

//Function to calculate average time 
void findavgTime( int processes[], int n, int bt[]) 
{ 
	int wt[n], tat[n], total_wt = 0, total_tat = 0; 

	//Function to find waiting time of all processes 
	findWaitingTime(processes, n, bt, wt); 

	//Function to find turn around time for all processes 
	findTurnAroundTime(processes, n, bt, wt, tat); 

	//Display processes along with all details 
	printf("Processes Burst time Waiting time Turn around time\n"); 

	// Calculate total waiting time and total turn 
	// around time 
	for (int i=0; i<n; i++) 
	{ 
		total_wt = total_wt + wt[i]; 
		total_tat = total_tat + tat[i]; 
		printf(" %d ",(i+1));
		printf("	 %d ", bt[i] );
		printf("	 %d",wt[i] );
		printf("	 %d\n",tat[i] ); 
	} 
	float s=(float)total_wt / (float)n;
	float t=(float)total_tat / (float)n;
	printf("Average waiting time = %f",s);
	printf("\n");
	printf("Average turn around time = %f ",t); 
} 

// Driver code 
int main() 
{ 
	//process id's 
	int processes[] = { 1, 2, 3}; 
	int n = sizeof processes / sizeof processes[0]; 

	//Burst time of all processes 
	int burst_time[] = {10, 5, 8}; 

	findavgTime(processes, n, burst_time); 
	return 0; 
} 
// This code is contributed by Shivi_Aggarwal
// C program for implementation of FCFS 
// scheduling 
#include<stdio.h> 
// Function to find the waiting time for all 
// processes 
void findWaitingTime(int processes[], int n, 
						int bt[], int wt[]) 
{ 
	// waiting time for first process is 0 
	wt[0] = 0; 

	// calculating waiting time 
	for (int i = 1; i < n ; i++ ) 
		wt[i] = bt[i-1] + wt[i-1] ; 
} 

// Function to calculate turn around time 
void findTurnAroundTime( int processes[], int n, 
				int bt[], int wt[], int tat[]) 
{ 
	// calculating turnaround time by adding 
	// bt[i] + wt[i] 
	for (int i = 0; i < n ; i++) 
		tat[i] = bt[i] + wt[i]; 
} 

//Function to calculate average time 
void findavgTime( int processes[], int n, int bt[]) 
{ 
	int wt[n], tat[n], total_wt = 0, total_tat = 0; 

	//Function to find waiting time of all processes 
	findWaitingTime(processes, n, bt, wt); 

	//Function to find turn around time for all processes 
	findTurnAroundTime(processes, n, bt, wt, tat); 

	//Display processes along with all details 
	printf("Processes Burst time Waiting time Turn around time\n"); 

	// Calculate total waiting time and total turn 
	// around time 
	for (int i=0; i<n; i++) 
	{ 
		total_wt = total_wt + wt[i]; 
		total_tat = total_tat + tat[i]; 
		printf(" %d ",(i+1));
		printf("	 %d ", bt[i] );
		printf("	 %d",wt[i] );
		printf("	 %d\n",tat[i] ); 
	} 
	float s=(float)total_wt / (float)n;
	float t=(float)total_tat / (float)n;
	printf("Average waiting time = %f",s);
	printf("\n");
	printf("Average turn around time = %f ",t); 
} 

// Driver code 
int main() 
{ 
	//process id's 
	int processes[] = { 1, 2, 3}; 
	int n = sizeof processes / sizeof processes[0]; 

	//Burst time of all processes 
	int burst_time[] = {10, 5, 8}; 

	findavgTime(processes, n, burst_time); 
	return 0; 
} 
// This code is contributed by Shivi_Aggarwal
// C program for implementation of FCFS 
// scheduling 
#include<stdio.h> 
// Function to find the waiting time for all 
// processes 
void findWaitingTime(int processes[], int n, 
						int bt[], int wt[]) 
{ 
	// waiting time for first process is 0 
	wt[0] = 0; 

	// calculating waiting time 
	for (int i = 1; i < n ; i++ ) 
		wt[i] = bt[i-1] + wt[i-1] ; 
} 

// Function to calculate turn around time 
void findTurnAroundTime( int processes[], int n, 
				int bt[], int wt[], int tat[]) 
{ 
	// calculating turnaround time by adding 
	// bt[i] + wt[i] 
	for (int i = 0; i < n ; i++) 
		tat[i] = bt[i] + wt[i]; 
} 

//Function to calculate average time 
void findavgTime( int processes[], int n, int bt[]) 
{ 
	int wt[n], tat[n], total_wt = 0, total_tat = 0; 

	//Function to find waiting time of all processes 
	findWaitingTime(processes, n, bt, wt); 

	//Function to find turn around time for all processes 
	findTurnAroundTime(processes, n, bt, wt, tat); 

	//Display processes along with all details 
	printf("Processes Burst time Waiting time Turn around time\n"); 

	// Calculate total waiting time and total turn 
	// around time 
	for (int i=0; i<n; i++) 
	{ 
		total_wt = total_wt + wt[i]; 
		total_tat = total_tat + tat[i]; 
		printf(" %d ",(i+1));
		printf("	 %d ", bt[i] );
		printf("	 %d",wt[i] );
		printf("	 %d\n",tat[i] ); 
	} 
	float s=(float)total_wt / (float)n;
	float t=(float)total_tat / (float)n;
	printf("Average waiting time = %f",s);
	printf("\n");
	printf("Average turn around time = %f ",t); 
} 

// Driver code 
int main() 
{ 
	//process id's 
	int processes[] = { 1, 2, 3}; 
	int n = sizeof processes / sizeof processes[0]; 

	//Burst time of all processes 
	int burst_time[] = {10, 5, 8}; 

	findavgTime(processes, n, burst_time); 
	return 0; 
} 
// This code is contributed by Shivi_Aggarwal
// C program for implementation of FCFS 
// scheduling 
#include<stdio.h> 
// Function to find the waiting time for all 
// processes 
void findWaitingTime(int processes[], int n, 
						int bt[], int wt[]) 
{ 
	// waiting time for first process is 0 
	wt[0] = 0; 

	// calculating waiting time 
	for (int i = 1; i < n ; i++ ) 
		wt[i] = bt[i-1] + wt[i-1] ; 
} 

// Function to calculate turn around time 
void findTurnAroundTime( int processes[], int n, 
				int bt[], int wt[], int tat[]) 
{ 
	// calculating turnaround time by adding 
	// bt[i] + wt[i] 
	for (int i = 0; i < n ; i++) 
		tat[i] = bt[i] + wt[i]; 
} 

//Function to calculate average time 
void findavgTime( int processes[], int n, int bt[]) 
{ 
	int wt[n], tat[n], total_wt = 0, total_tat = 0; 

	//Function to find waiting time of all processes 
	findWaitingTime(processes, n, bt, wt); 

	//Function to find turn around time for all processes 
	findTurnAroundTime(processes, n, bt, wt, tat); 

	//Display processes along with all details 
	printf("Processes Burst time Waiting time Turn around time\n"); 

	// Calculate total waiting time and total turn 
	// around time 
	for (int i=0; i<n; i++) 
	{ 
		total_wt = total_wt + wt[i]; 
		total_tat = total_tat + tat[i]; 
		printf(" %d ",(i+1));
		printf("	 %d ", bt[i] );
		printf("	 %d",wt[i] );
		printf("	 %d\n",tat[i] ); 
	} 
	float s=(float)total_wt / (float)n;
	float t=(float)total_tat / (float)n;
	printf("Average waiting time = %f",s);
	printf("\n");
	printf("Average turn around time = %f ",t); 
} 

// Driver code 
int main() 
{ 
	//process id's 
	int processes[] = { 1, 2, 3}; 
	int n = sizeof processes / sizeof processes[0]; 

	//Burst time of all processes 
	int burst_time[] = {10, 5, 8}; 

	findavgTime(processes, n, burst_time); 
	return 0; 
} 
// This code is contributed by Shivi_Aggarwal
// C program for implementation of FCFS 
// scheduling 
#include<stdio.h> 
// Function to find the waiting time for all 
// processes 
void findWaitingTime(int processes[], int n, 
						int bt[], int wt[]) 
{ 
	// waiting time for first process is 0 
	wt[0] = 0; 

	// calculating waiting time 
	for (int i = 1; i < n ; i++ ) 
		wt[i] = bt[i-1] + wt[i-1] ; 
} 

// Function to calculate turn around time 
void findTurnAroundTime( int processes[], int n, 
				int bt[], int wt[], int tat[]) 
{ 
	// calculating turnaround time by adding 
	// bt[i] + wt[i] 
	for (int i = 0; i < n ; i++) 
		tat[i] = bt[i] + wt[i]; 
} 

//Function to calculate average time 
void findavgTime( int processes[], int n, int bt[]) 
{ 
	int wt[n], tat[n], total_wt = 0, total_tat = 0; 

	//Function to find waiting time of all processes 
	findWaitingTime(processes, n, bt, wt); 

	//Function to find turn around time for all processes 
	findTurnAroundTime(processes, n, bt, wt, tat); 

	//Display processes along with all details 
	printf("Processes Burst time Waiting time Turn around time\n"); 

	// Calculate total waiting time and total turn 
	// around time 
	for (int i=0; i<n; i++) 
	{ 
		total_wt = total_wt + wt[i]; 
		total_tat = total_tat + tat[i]; 
		printf(" %d ",(i+1));
		printf("	 %d ", bt[i] );
		printf("	 %d",wt[i] );
		printf("	 %d\n",tat[i] ); 
	} 
	float s=(float)total_wt / (float)n;
	float t=(float)total_tat / (float)n;
	printf("Average waiting time = %f",s);
	printf("\n");
	printf("Average turn around time = %f ",t); 
} 

// Driver code 
int main() 
{ 
	//process id's 
	int processes[] = { 1, 2, 3}; 
	int n = sizeof processes / sizeof processes[0]; 

	//Burst time of all processes 
	int burst_time[] = {10, 5, 8}; 

	findavgTime(processes, n, burst_time); 
	return 0; 
} 
// This code is contributed by Shivi_Aggarwal
// C program for implementation of FCFS 
// scheduling 
#include<stdio.h> 
// Function to find the waiting time for all 
// processes 
void findWaitingTime(int processes[], int n, 
						int bt[], int wt[]) 
{ 
	// waiting time for first process is 0 
	wt[0] = 0; 

	// calculating waiting time 
	for (int i = 1; i < n ; i++ ) 
		wt[i] = bt[i-1] + wt[i-1] ; 
} 

// Function to calculate turn around time 
void findTurnAroundTime( int processes[], int n, 
				int bt[], int wt[], int tat[]) 
{ 
	// calculating turnaround time by adding 
	// bt[i] + wt[i] 
	for (int i = 0; i < n ; i++) 
		tat[i] = bt[i] + wt[i]; 
} 

//Function to calculate average time 
void findavgTime( int processes[], int n, int bt[]) 
{ 
	int wt[n], tat[n], total_wt = 0, total_tat = 0; 

	//Function to find waiting time of all processes 
	findWaitingTime(processes, n, bt, wt); 

	//Function to find turn around time for all processes 
	findTurnAroundTime(processes, n, bt, wt, tat); 

	//Display processes along with all details 
	printf("Processes Burst time Waiting time Turn around time\n"); 

	// Calculate total waiting time and total turn 
	// around time 
	for (int i=0; i<n; i++) 
	{ 
		total_wt = total_wt + wt[i]; 
		total_tat = total_tat + tat[i]; 
		printf(" %d ",(i+1));
		printf("	 %d ", bt[i] );
		printf("	 %d",wt[i] );
		printf("	 %d\n",tat[i] ); 
	} 
	float s=(float)total_wt / (float)n;
	float t=(float)total_tat / (float)n;
	printf("Average waiting time = %f",s);
	printf("\n");
	printf("Average turn around time = %f ",t); 
} 

// Driver code 
int main() 
{ 
	//process id's 
	int processes[] = { 1, 2, 3}; 
	int n = sizeof processes / sizeof processes[0]; 

	//Burst time of all processes 
	int burst_time[] = {10, 5, 8}; 

	findavgTime(processes, n, burst_time); 
	return 0; 
} 
// This code is contributed by Shivi_Aggarwal
// C program for implementation of FCFS 
// scheduling 
#include<stdio.h> 
// Function to find the waiting time for all 
// processes 
void findWaitingTime(int processes[], int n, 
						int bt[], int wt[]) 
{ 
	// waiting time for first process is 0 
	wt[0] = 0; 

	// calculating waiting time 
	for (int i = 1; i < n ; i++ ) 
		wt[i] = bt[i-1] + wt[i-1] ; 
} 

// Function to calculate turn around time 
void findTurnAroundTime( int processes[], int n, 
				int bt[], int wt[], int tat[]) 
{ 
	// calculating turnaround time by adding 
	// bt[i] + wt[i] 
	for (int i = 0; i < n ; i++) 
		tat[i] = bt[i] + wt[i]; 
} 

//Function to calculate average time 
void findavgTime( int processes[], int n, int bt[]) 
{ 
	int wt[n], tat[n], total_wt = 0, total_tat = 0; 

	//Function to find waiting time of all processes 
	findWaitingTime(processes, n, bt, wt); 

	//Function to find turn around time for all processes 
	findTurnAroundTime(processes, n, bt, wt, tat); 

	//Display processes along with all details 
	printf("Processes Burst time Waiting time Turn around time\n"); 

	// Calculate total waiting time and total turn 
	// around time 
	for (int i=0; i<n; i++) 
	{ 
		total_wt = total_wt + wt[i]; 
		total_tat = total_tat + tat[i]; 
		printf(" %d ",(i+1));
		printf("	 %d ", bt[i] );
		printf("	 %d",wt[i] );
		printf("	 %d\n",tat[i] ); 
	} 
	float s=(float)total_wt / (float)n;
	float t=(float)total_tat / (float)n;
	printf("Average waiting time = %f",s);
	printf("\n");
	printf("Average turn around time = %f ",t); 
} 

// Driver code 
int main() 
{ 
	//process id's 
	int processes[] = { 1, 2, 3}; 
	int n = sizeof processes / sizeof processes[0]; 

	//Burst time of all processes 
	int burst_time[] = {10, 5, 8}; 

	findavgTime(processes, n, burst_time); 
	return 0; 
} 
// This code is contributed by Shivi_Aggarwal
// C program for implementation of FCFS 
// scheduling 
#include<stdio.h> 
// Function to find the waiting time for all 
// processes 
void findWaitingTime(int processes[], int n, 
						int bt[], int wt[]) 
{ 
	// waiting time for first process is 0 
	wt[0] = 0; 

	// calculating waiting time 
	for (int i = 1; i < n ; i++ ) 
		wt[i] = bt[i-1] + wt[i-1] ; 
} 

// Function to calculate turn around time 
void findTurnAroundTime( int processes[], int n, 
				int bt[], int wt[], int tat[]) 
{ 
	// calculating turnaround time by adding 
	// bt[i] + wt[i] 
	for (int i = 0; i < n ; i++) 
		tat[i] = bt[i] + wt[i]; 
} 

//Function to calculate average time 
void findavgTime( int processes[], int n, int bt[]) 
{ 
	int wt[n], tat[n], total_wt = 0, total_tat = 0; 

	//Function to find waiting time of all processes 
	findWaitingTime(processes, n, bt, wt); 

	//Function to find turn around time for all processes 
	findTurnAroundTime(processes, n, bt, wt, tat); 

	//Display processes along with all details 
	printf("Processes Burst time Waiting time Turn around time\n"); 

	// Calculate total waiting time and total turn 
	// around time 
	for (int i=0; i<n; i++) 
	{ 
		total_wt = total_wt + wt[i]; 
		total_tat = total_tat + tat[i]; 
		printf(" %d ",(i+1));
		printf("	 %d ", bt[i] );
		printf("	 %d",wt[i] );
		printf("	 %d\n",tat[i] ); 
	} 
	float s=(float)total_wt / (float)n;
	float t=(float)total_tat / (float)n;
	printf("Average waiting time = %f",s);
	printf("\n");
	printf("Average turn around time = %f ",t); 
} 

// Driver code 
int main() 
{ 
	//process id's 
	int processes[] = { 1, 2, 3}; 
	int n = sizeof processes / sizeof processes[0]; 

	//Burst time of all processes 
	int burst_time[] = {10, 5, 8}; 

	findavgTime(processes, n, burst_time); 
	return 0; 
} 
// This code is contributed by Shivi_Aggarwal
// C program for implementation of FCFS 
// scheduling 
#include<stdio.h> 
// Function to find the waiting time for all 
// processes 
void findWaitingTime(int processes[], int n, 
						int bt[], int wt[]) 
{ 
	// waiting time for first process is 0 
	wt[0] = 0; 

	// calculating waiting time 
	for (int i = 1; i < n ; i++ ) 
		wt[i] = bt[i-1] + wt[i-1] ; 
} 

// Function to calculate turn around time 
void findTurnAroundTime( int processes[], int n, 
				int bt[], int wt[], int tat[]) 
{ 
	// calculating turnaround time by adding 
	// bt[i] + wt[i] 
	for (int i = 0; i < n ; i++) 
		tat[i] = bt[i] + wt[i]; 
} 

//Function to calculate average time 
void findavgTime( int processes[], int n, int bt[]) 
{ 
	int wt[n], tat[n], total_wt = 0, total_tat = 0; 

	//Function to find waiting time of all processes 
	findWaitingTime(processes, n, bt, wt); 

	//Function to find turn around time for all processes 
	findTurnAroundTime(processes, n, bt, wt, tat); 

	//Display processes along with all details 
	printf("Processes Burst time Waiting time Turn around time\n"); 

	// Calculate total waiting time and total turn 
	// around time 
	for (int i=0; i<n; i++) 
	{ 
		total_wt = total_wt + wt[i]; 
		total_tat = total_tat + tat[i]; 
		printf(" %d ",(i+1));
		printf("	 %d ", bt[i] );
		printf("	 %d",wt[i] );
		printf("	 %d\n",tat[i] ); 
	} 
	float s=(float)total_wt / (float)n;
	float t=(float)total_tat / (float)n;
	printf("Average waiting time = %f",s);
	printf("\n");
	printf("Average turn around time = %f ",t); 
} 

// Driver code 
int main() 
{ 
	//process id's 
	int processes[] = { 1, 2, 3}; 
	int n = sizeof processes / sizeof processes[0]; 

	//Burst time of all processes 
	int burst_time[] = {10, 5, 8}; 

	findavgTime(processes, n, burst_time); 
	return 0; 
} 
// This code is contributed by Shivi_Aggarwal
// C program for implementation of FCFS 
// scheduling 
#include<stdio.h> 
// Function to find the waiting time for all 
// processes 
void findWaitingTime(int processes[], int n, 
						int bt[], int wt[]) 
{ 
	// waiting time for first process is 0 
	wt[0] = 0; 

	// calculating waiting time 
	for (int i = 1; i < n ; i++ ) 
		wt[i] = bt[i-1] + wt[i-1] ; 
} 

// Function to calculate turn around time 
void findTurnAroundTime( int processes[], int n, 
				int bt[], int wt[], int tat[]) 
{ 
	// calculating turnaround time by adding 
	// bt[i] + wt[i] 
	for (int i = 0; i < n ; i++) 
		tat[i] = bt[i] + wt[i]; 
} 

//Function to calculate average time 
void findavgTime( int processes[], int n, int bt[]) 
{ 
	int wt[n], tat[n], total_wt = 0, total_tat = 0; 

	//Function to find waiting time of all processes 
	findWaitingTime(processes, n, bt, wt); 

	//Function to find turn around time for all processes 
	findTurnAroundTime(processes, n, bt, wt, tat); 

	//Display processes along with all details 
	printf("Processes Burst time Waiting time Turn around time\n"); 

	// Calculate total waiting time and total turn 
	// around time 
	for (int i=0; i<n; i++) 
	{ 
		total_wt = total_wt + wt[i]; 
		total_tat = total_tat + tat[i]; 
		printf(" %d ",(i+1));
		printf("	 %d ", bt[i] );
		printf("	 %d",wt[i] );
		printf("	 %d\n",tat[i] ); 
	} 
	float s=(float)total_wt / (float)n;
	float t=(float)total_tat / (float)n;
	printf("Average waiting time = %f",s);
	printf("\n");
	printf("Average turn around time = %f ",t); 
} 

// Driver code 
int main() 
{ 
	//process id's 
	int processes[] = { 1, 2, 3}; 
	int n = sizeof processes / sizeof processes[0]; 

	//Burst time of all processes 
	int burst_time[] = {10, 5, 8}; 

	findavgTime(processes, n, burst_time); 
	return 0; 
} 
// This code is contributed by Shivi_Aggarwal
// C program for implementation of FCFS 
// scheduling 
#include<stdio.h> 
// Function to find the waiting time for all 
// processes 
void findWaitingTime(int processes[], int n, 
						int bt[], int wt[]) 
{ 
	// waiting time for first process is 0 
	wt[0] = 0; 

	// calculating waiting time 
	for (int i = 1; i < n ; i++ ) 
		wt[i] = bt[i-1] + wt[i-1] ; 
} 

// Function to calculate turn around time 
void findTurnAroundTime( int processes[], int n, 
				int bt[], int wt[], int tat[]) 
{ 
	// calculating turnaround time by adding 
	// bt[i] + wt[i] 
	for (int i = 0; i < n ; i++) 
		tat[i] = bt[i] + wt[i]; 
} 

//Function to calculate average time 
void findavgTime( int processes[], int n, int bt[]) 
{ 
	int wt[n], tat[n], total_wt = 0, total_tat = 0; 

	//Function to find waiting time of all processes 
	findWaitingTime(processes, n, bt, wt); 

	//Function to find turn around time for all processes 
	findTurnAroundTime(processes, n, bt, wt, tat); 

	//Display processes along with all details 
	printf("Processes Burst time Waiting time Turn around time\n"); 

	// Calculate total waiting time and total turn 
	// around time 
	for (int i=0; i<n; i++) 
	{ 
		total_wt = total_wt + wt[i]; 
		total_tat = total_tat + tat[i]; 
		printf(" %d ",(i+1));
		printf("	 %d ", bt[i] );
		printf("	 %d",wt[i] );
		printf("	 %d\n",tat[i] ); 
	} 
	float s=(float)total_wt / (float)n;
	float t=(float)total_tat / (float)n;
	printf("Average waiting time = %f",s);
	printf("\n");
	printf("Average turn around time = %f ",t); 
} 

// Driver code 
int main() 
{ 
	//process id's 
	int processes[] = { 1, 2, 3}; 
	int n = sizeof processes / sizeof processes[0]; 

	//Burst time of all processes 
	int burst_time[] = {10, 5, 8}; 

	findavgTime(processes, n, burst_time); 
	return 0; 
} 
// This code is contributed by Shivi_Aggarwal
// C program for implementation of FCFS 
// scheduling 
#include<stdio.h> 
// Function to find the waiting time for all 
// processes 
void findWaitingTime(int processes[], int n, 
						int bt[], int wt[]) 
{ 
	// waiting time for first process is 0 
	wt[0] = 0; 

	// calculating waiting time 
	for (int i = 1; i < n ; i++ ) 
		wt[i] = bt[i-1] + wt[i-1] ; 
} 

// Function to calculate turn around time 
void findTurnAroundTime( int processes[], int n, 
				int bt[], int wt[], int tat[]) 
{ 
	// calculating turnaround time by adding 
	// bt[i] + wt[i] 
	for (int i = 0; i < n ; i++) 
		tat[i] = bt[i] + wt[i]; 
} 

//Function to calculate average time 
void findavgTime( int processes[], int n, int bt[]) 
{ 
	int wt[n], tat[n], total_wt = 0, total_tat = 0; 

	//Function to find waiting time of all processes 
	findWaitingTime(processes, n, bt, wt); 

	//Function to find turn around time for all processes 
	findTurnAroundTime(processes, n, bt, wt, tat); 

	//Display processes along with all details 
	printf("Processes Burst time Waiting time Turn around time\n"); 

	// Calculate total waiting time and total turn 
	// around time 
	for (int i=0; i<n; i++) 
	{ 
		total_wt = total_wt + wt[i]; 
		total_tat = total_tat + tat[i]; 
		printf(" %d ",(i+1));
		printf("	 %d ", bt[i] );
		printf("	 %d",wt[i] );
		printf("	 %d\n",tat[i] ); 
	} 
	float s=(float)total_wt / (float)n;
	float t=(float)total_tat / (float)n;
	printf("Average waiting time = %f",s);
	printf("\n");
	printf("Average turn around time = %f ",t); 
} 

// Driver code 
int main() 
{ 
	//process id's 
	int processes[] = { 1, 2, 3}; 
	int n = sizeof processes / sizeof processes[0]; 

	//Burst time of all processes 
	int burst_time[] = {10, 5, 8}; 

	findavgTime(processes, n, burst_time); 
	return 0; 
} 
// This code is contributed by Shivi_Aggarwal
